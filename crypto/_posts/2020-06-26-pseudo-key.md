---
layout: post
title: "pseudo-key"
author: "shreyas-sriram"
---

# Challenge
Keys are not always as they seem...

Note: Make sure to wrap the plaintext with `flag{}` before you submit!

## Files
* [pseudo-key.py]({{site.baseurl}}/assets/pseudo-key/pseudo-key.py)
* [pseudo-key-output.txt]({{site.baseurl}}/assets/pseudo-key/pseudo-key-output.txt)

# Solution

* It is obvious from `pseudo-key.py` that the encryption is **Vigenere Cipher**
* Notice that the `pseudo-key` in `pseudo-key-output.txt` is generated by encryption the **original key by itself**<br/>
`pseudo-key = encrypt(key, key) `
* Going through the possible combinations of **(x,x)** which give the characters of `pseudo-key`, we get the following :<br/>

```
Pseudo-key: iigesssaemk

i : (e, r)
g : (d, q)
e : (c, p)
s : (j, w)
a : (a, n)
m : (g, t)
k : (f, s)
```
* Using these letters, all the possible keys can be found

## Solution Code for Generating Key Combinations

```
import itertools

# iigesssaemk

result = list(itertools.product("er","er", "dq", "cp", "jw", "jw", "jw", "an", "cp", "gt", "fs"))

with open('keys.txt', 'w') as f:
    for item in result:
        f.write("{}\n".format(''.join(item)))

print("keys are written to file")
```
* The required key is among the generated keys, but the exact key is unknown
* To find the **plaintext**, decrypt the given **ciphertext** using the **generated keys**

## Solution Code to Decrypt Ciphertext

```
#!/usr/bin/env python3

from string import ascii_lowercase

chr_to_num = {c: i for i, c in enumerate(ascii_lowercase)}
num_to_chr = {i: c for i, c in enumerate(ascii_lowercase)}

def decrypt(ptxt, key):
    ptxt = ptxt.lower()
    key = ''.join(key[i % len(key)] for i in range(len(ptxt))).lower()
    ctxt = ''
    for i in range(len(ptxt)):
        if ptxt[i] == '_':
            ctxt += '_'
            continue
        x = chr_to_num[ptxt[i]]
        y = chr_to_num[key[i]]
        ctxt += num_to_chr[(x - y) % 26]
    return ctxt

ctxt = 'z_jjaoo_rljlhr_gauf_twv_shaqzb_ljtyut'
result = []

with open('keys.txt') as f:
    lines = f.read().splitlines()

for key in lines :
        result.append(decrypt(ctxt,key))

with open('results.txt', 'w') as f:
    for item in result:
        f.write("{}\n".format(item))

```

* Going through the file `results.txt`, one can make an educated guess of the words used in the **plaintext**
* Use `cat results.txt | grep i_guess_pseudo_keys_are` to get the **plaintext**, which is also the **flag**<br/>
` flag{i_guess_pseudo_keys_are_pseudo_secure} `